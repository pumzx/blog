# 程序员修炼之道-从小工到专家

[TOC]



## 第1章：注重实效的哲学

### 1 我的源码让猫给吃了

​	对自己的职业生涯负责，并且不害怕承认无知或错误。

​	不要为自己的错误找借口，而要提供解决方案。

### 2 软件的熵

​	熵指的是某个系统中“无序”的总量，熵越大系统越混乱。在软件领域，当软件中的无序增长时，程序员们称之为“软件腐烂”。

> ​	破窗户理论：一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑的居民带来一种废弃感---一种职权部门不关心这座建筑的感觉。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，严重的结构损坏开始了。在相对较短的一段时间里，建筑就被损毁的超出了业主愿意修理的程度，而废弃感变成了现实。

​	破窗户理论对与软件领域的启发：不要留着“破窗户”（低劣的设计，错误决策，或是糟糕的代码）不修。发现一个就修一个，如果暂时没有时间，就先把出问题的代码注释，或者标记“未实现”，或者用虚拟数据代替。反之，如果项目的代码很漂亮，设计良好，编码整洁，并且很优雅，那么参与者很可能会格外注意不去把它弄脏，即使在时间很紧张的情况下。

[^破窗户理论，注：]: 真的是这样的，在系统中，代码风格很统一，大家都会自觉遵收。另外如果每个人都有一颗不愿产生破窗户或修复破窗户的心，系统也将变得更好。

### 3 石头汤与煮青蛙

​	故事：士兵利用村民的好奇，从他们那弄到食物，把他们团结起来，和他们一起做到了他们自己本来做不到的事情---一项协作的成果。最后每个人都是赢家。

​	启发：在某些情况下，我们也许确切的知道需要做什么以及怎么做。但是去请求许可去做的时候，由于资源分布到各个不同的部门，每个部门都会护卫他们自己的资源，所以会遇到很多阻力。这个时候就要拿出“石头”，设计好，开发好，拿出来给大家看，让所有人大吃一惊，然后说“要是我们增加xxx，可能会更好”，假装那并不重要，等待他们增加我们想要的东西。人们发现，参与正在发生的成功要更容易。让他们瞥见未来，你就能让他们聚焦在你周围。

### 4 足够好的软件

​	让用户参与权衡你的软件，满足用户的需求，包括市场人员对外承诺的期限，最终用户的计划，公司的现金流等。如果无视这些需求，一味的给程序增加新特性，润饰代码，这不是职业素养的做法，当然也不说提倡慌张，许诺不可能完成的时间，为赶deadline削减功能，这同样没有职业素养。

​	让质量成为需求问题。

​	知道何时止步，不要过度修饰和过于求精而毁损完好的程序。让你的代码凭着自己的质量飞一会儿，它也许不完美，但它不可能完美！（充满了哲学意味）

### 5 你的知识资产

​	**如何经营你的知识资产？**

- **定期投资**：定期为你的知识资产投资，即使投资量很小，习惯自身也和总量一样重要。不仅要定期投资也要养成这个习惯。
- 多元化：你知道的不同的事情越多，你就越有价值。底线是知道你目前所用的特定技术的各种特性。但不能就此止步，技术更新更快，掌握的越多，就能更好的进行调整，赶上变化。
- 管理风险：不要把你所有的技术鸡蛋放在一个篮子里
- 低买高卖：在新兴技术流行起来之前就学习它，这是高风险也是高回报的。就像java刚出现就学习它，如果到现在，已经步入该领域的顶尖行列了。
- 重新评估与平衡：技术日新月异，重温好久没使用过的技术，或者学习另一门语言。

​	**目标**

- 每年至少学习一种新语言：不同语言以不同方式解决相同的问题。通过学习若干不同的方法，可以帮助你拓宽你的思维，并避免墨守成规。（我今年需要学会go)

- 每季度阅读一本技术书籍：一旦养成习惯，就一个月读一本书，先从与当前工作使用的技术相关的书籍开始，掌握之后，在读一些与工作中的技术无关的书籍

- 也要阅读非技术书籍：提升自我的综合素质，作为一个人，这很重要。

- 上课：在本地的大学或者会展论坛寻找有趣的课程

- 参加本地用户组织：不要只是去听讲，而要主动参与。不能与世隔绝，打听一下你们公司以外的人都在做什么

- 实验不同的环境：如果在Windows工作，就试一下Linux。如果只用makefile和编辑器就试试IDE，反之亦然。

- 跟上潮流：订阅期刊，选择所涵盖的技术与你当前的项目不同的刊物。扩展视野

- 上网：网上搜索想要的知识

  持续投入十分重要，一旦熟悉某种新语言或新技术，继续前进学习另一种。学习的过程将扩展你的思维，设法把你学到的东西应用到当前的项目中，即使你的项目没有使用该技术，借鉴一些思想运用进来也是好的。

​	**学习的机会**

​		遇到不懂的问题，一定要去找答案，请教别人，上网。和别人交谈可以帮助你建立人际网络，还会增长知识资产。

​		时间很短缺，让自己的空闲时间里总有东西可读。

​	**批评性的思考**

​		批判性的思考你读到的和听到的。不是排在第一位的就是最好的，它可能付费了

### 6 交流！

​	没有有效的交流，一个好的想法就只是一个无人关心的孤儿。

​	**知道你想要说什么**

​		规划你想要说的东西，写出大纲，然后问自己：“这是否讲清楚了我想要说的所有内容？”，提炼他，直到确实如此为止。

​	**了解你的听众**

​		了解你的听众的需要，兴趣和能力。听众不同，介绍和交流的方式不同。

​	**选择时机**

​		要让你所说的适得其时，在内容上切实相关。

​	**选择风格**

​		调整你的交流风格，让其适应你的听众。

​	**让文档美观**

​		不要认为这是一件麻烦的事情，就像一个厨师会说，你可以在厨房忙碌几个小时，最后却会因为饭菜糟糕的外观毁掉你所有的努力。

​	**让听众参与**

​		让你的读者参与文档早期草稿的制作，获取他们的反馈，并汲取他们的智慧。你将建立良好的工作关系，并很可能在此过程中制作出更好的文档

​	**做倾听者**

​		如果不听他们说话，他们也不会听你说话，即使你掌握全部信息。鼓励大家通过提问的方式来交谈，或是让他们总结你告诉他们的东西，把会议变成对话，你将能更有效的阐明你的观点。

​	**回复他人**

​		不要忘记且礼貌地回复他人给你发的消息

## 第2章：注重实效的途径
这一章主要是教我们怎么做。
### 7 重复的危害
>DRY - Don't Repeat Yourself

>DRY原则：系统中的每一项知识都必须具有单一、无歧义、权威的表示。

##### 重复是怎样发生的？

**强加的重复**：

   *信息的多种表示* ：客户端和服务端使用不同的语言，需要表示某种共有的结构。这个时候不要两边都分别写，而是使用过滤器或者代码生成器，根据公共的元数据构建多种语言下的结构。

   *代码中的文档* ：糟糕的代码才需要注释，把浅显易懂的知识放在代码里，把高级的说明写在文档里。如果注释没有及时更新，那么没有注释比错误的注释更好。

   *文档与代码* ： 在项目排期很紧张的时候很可能就不会去管文档的更新了。如果拿文档来生成测试案例，并且每次交付时都通过所有的测试，当需求变了，测试案例也会变，这个过程就是健全的。

**无意的重复**：

在一些缓存数据中，可能会因为性能原因，违反DRY原则。比如表示一条线段，除了起点和终点，还有线段的长度。显然长度不应该成为线段的属性，而且通过起终点计算出来，但为了性能，还是可以增加长度属性，不然每次访问都要重复计算。重要的是要使影响局部化，对DRY的违反没有暴露给外界，只有类中的方法需要注意保持行为良好。

**无耐性的重复**：

如果为了赶进度，去copy原来的源码，没有仔细思考，造成日后花更多的时间去修改维护。“欲速则不达”。

**开发者之间的重复**：

有些公共的功能可能被不同的模块开发者重复实现了，这个时候就需要开发者多沟通交流，多看看和学习大家提交的代码，要复用已有的代码，不要重复造轮子！

### 8 正交性
在计算机技术中，正交性是表示某种不相依赖或是解耦性，如果两个或是更多事物中的一个发生变化，不会影响其他事物，这些事物就是正交的。例如界面设计与数据库种类

当任何系统的各组件互相高度依赖时，就不再有局部修正这样的事情。

>要消除无关事物之间的影响。

##### 正交的好处
**提高生产率**

改动得以局部化。开发与测试范围减少了

促进复用。可以组合其他组件形成新的功能。不需要重复造轮子

生产率提高。M x N的效率提升

**降低风险**

问题代码被隔离开，不会扩散，易于替换。

系统更健壮。特定区域的改动所导致的影响只会局限在此区域内

更好的测试。

##### 项目团队

划分团队的责任，分为不同功能的小组，使得重叠度降至最低

##### 设计

系统模块化，各个模块不相互依赖

分层，每层只使用在其下面的层次提供的抽象

##### 工具箱与库

引入的工具与库不会对代码进行不必要的改动。如果要以特殊的方式创建对象就是非正交的。

正交性的一个变体就是AOP。

##### 编码

让你的代码保持解耦。如果要改变对象的状态，让对象自己去做，不要暴露给外界。保持外界的隔离。

避免使用全局数据。

避免编写相似的函数。使用策略模式

养成重构的习惯

##### 测试

正交的系统让更多的系统测试在单个模块中完成。

##### 文档

##### 认同正交性

运用正交性原则可以降低系统各组件间的相互依赖。



### 9 可撤销性

不存在最终决策，我们的决策可能会因为某些原因改变，比如更换数据库，这个时候能做的就是在此之前做好准备，并且高度抽象数据库只是提供持久化数据的能力，这样才能有中流换马的灵活性。

**灵活的架构**

一般把第三方库隐藏在抽象的接口后，如果无法彻底隔离则把该需求放入元数据，使用某种机制（Aspect）把必需的语句插入到代码自身中。这样才可撤销。

### 10 曳光弹

曳光弹工作在生产环境中，能够及时得到反馈，找到目标，快速试错。

优点：

用户能够及早的看到能工作的东西。

开发者构建了一个他们能在其中工作的结构

你有了一个集成平台。

你有了可用于演示的东西。

你将更能够感觉到工作进展。

### 11 原型与便笺

原型就是能够快速反应结果的一种开发方式，代码可以忽略不重要的细节。

应制作原型的事物：

架构

已有系统中的新功能

外部数据的结构或内容

第三方工具或组件

性能问题

用户界面设计

> 为了学习而制作原型

在构建原型时，可以忽略的细节：

正确性：虚拟的数据

完整性：可能只有一个功能

健壮性：错误检查不完整

风格：没有注释和文档

### 12 领域语言

用靠近问题领域的语言表示问题。

### 13 估算

学会估算让人对事物的数量级有直觉的程度，可以确定事物的可行性。

估算的单位度量很重要

理解提问内容

建立系统的模型

把模型分解为组件：确认参数

给每个参数指定值

计算答案：得到奇怪的答案，计算又是正确的，那么模型可能就是错误的

追踪你的估算能力

估算项目进度



## 第3章 基本工具

要与工匠一样，想着定期增添工具，要总是寻找更好的做事方式。

### 14 纯文本的威力

保证不过时

杠杠作用

更易于测试

### 15 shell游戏

shell有更加强大的能力，能够组合多种命令，并使其自动化。而Windows下的图形界面操作则显得麻烦。

花一些精力熟悉命令行，能够帮助提高效率。

### 16 强力编辑

最好精通一种编辑器，并将其用作所有的编辑任务，包括代码，文档，备忘录，系统管理等

编辑器应该具备的特性：

可配置：按照个人偏好配置，手最好不用离开键盘

可扩展：能继承你在使用的任何编译器环境

可编程：对编辑器编程，让其执行复杂，多步骤的任务

### 17 源码控制

善用源码控制系统

### 18 调试

> 要修正问题，而不是发出指责

调试的思维方式：

1、不要恐慌。看到bug不要觉得不可能，那不仅可能，并且已经发生了。

2、确保能够成功编译代码---没有警告

3、跟bug的提出者沟通，搜集更多的数据

4、自己的测试不足以覆盖各种场景，需要进行全面的测试

找到问题的一种方法上向别人解释它，常常就会发现问题所在。

在遇到问题时，先消除自己的应用程序的问题，再考虑第三方的问题。

### 19 文本操纵

用脚本自动生成sql语句

用脚本自动生成Java的getter setter方法

用脚本生产测试数据

### 20 代码生成器

被动代码生成器：

本质上说参数化模板，根据一组输入生成给定的输出。只需要运行一次。

用来，创建新的源文件；在编程语言之间进行一次转换；生成查找表及其他在运行时计算很贵的资源。

主动代码生成器：

生成的输出形式上按需生成，可以用过就扔。

当需要处理两种环境时，比如数据库和访问数据的编程语言，就可以使用主动代码生成器来根据schema变化时，访问他的代码也随之自动变化。就像修改数据库列命，Java的bean的名字也自动改变。

代码生成器不一定要生成代码。可以是html等其他格式的文本。

**或许可以自己写出一些工具来---todo**



## 第4章 注重实效的偏执

### 21 按合约设计

用文档记载（并约定）软件模块的权利与责任，以确保程序的正确性。程序的正确性是做它声明要做的事情的程序，用文档记载这样的声明，并进行校验，是按合约设计的核心所在。

按合约设计（DBC）的期望与陈述

前条件：为了调用程序，必须为真的条件

后条件：程序保证会做的事情，程序完成时的状态，有后条件代表程序一定会结束。

类不变项：类确保从调用者的视角来看，该条件总是为真。

使用按合约设计的最大的好处是它迫使需求与保证的问题走到前台来，在设计时简单列举输入域的范围值时什么，边界条件是什么，程序允许交付什么，或者更重要的是它不允许交付什么。

使用**断言**模拟部分合约的设计

通过使用DBC可以达到早奔溃的效果，前条件不满足的情况下会尽早的暴露问题。

### 22 死程序不说谎

尽早的检测问题的好处之一就是可以更早的奔溃。不要让程序继续执行危害现有的环境。

### 23 断言式编程

不能使用断言代替真正的错误处理，决不能把必须执行的代码放在断言中。断言检查的事绝不应该发生的事情。

让断言在正式环境中开着。

断言的副作用：可能会对执行语句造成影响

### 24 何时使用异常

将异常用于异常的问题。如果打开一个文件，这个文件共识上是一定存在的，那么不存在就是异常，就应该使用异常捕获；如果这个文件可能不存在，那么真的不存在时就是一个正常的错误，就应该抛出异常。

如果把异常用作正常处理的一部分的程序，那么就会破坏封装性。通过异常处理，程序和他们的调用者被更紧密的耦合在一起。

错误处理器

### 25 怎样配平资源

你分配资源---使用它---然后解除其分配

配平资源就是打开和关闭在同一个地方，且一定会都执行。

嵌套的分配：以资源分配的次序相反的次序解除资源的分配。这样如果一个资源含有对另一个资源的引用，就不会造成资源被遗弃。

在代码不同的地方以相同的次序分配资源，可以避免死锁。

Java的finally子句可以保证资源被配平

构建代码，对资源确实得到了适当释放进行实际检查，使用包装对此进行检查。